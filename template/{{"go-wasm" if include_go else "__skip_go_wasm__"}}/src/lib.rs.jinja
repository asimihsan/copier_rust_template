use std::time::{SystemTime, UNIX_EPOCH};
use {{ project_slug_underscore }}_core::parse;

// Use Talc allocator for WebAssembly
#[cfg(target_arch = "wasm32")]
use talc::*;

// Set Talc as the global allocator for WebAssembly
#[cfg(target_arch = "wasm32")]
#[global_allocator]
static ALLOCATOR: TalckWasm = unsafe { TalckWasm::new_global() };

/// Version of the WASM interface
pub const VERSION: &str = "1.0.0";

// Memory management helpers
static mut RESULT_PTR: *mut u8 = std::ptr::null_mut();
static mut RESULT_LEN: usize = 0;
static mut RESULT_CAP: usize = 0;

/// Allocates memory that can be accessed from the host.
/// 
/// # Safety
///
/// Returns a pointer to the allocated memory.
/// The memory must be freed using `deallocate`.
#[no_mangle]
pub unsafe extern "C" fn allocate(size: usize) -> *mut u8 {
    let layout = std::alloc::Layout::from_size_align(size, 8).unwrap();
    std::alloc::alloc(layout)
}

/// Deallocates memory previously allocated with `allocate`.
/// 
/// # Safety
///
/// The pointer must have been allocated with `allocate`.
#[no_mangle]
pub unsafe extern "C" fn deallocate(ptr: *mut u8, size: usize) {
    if !ptr.is_null() {
        let layout = std::alloc::Layout::from_size_align(size, 8).unwrap();
        std::alloc::dealloc(ptr, layout);
    }
}

/// Store a string in memory and return its pointer and length.
/// The caller is responsible for calling `deallocate_result` to free the memory.
#[no_mangle]
pub unsafe extern "C" fn set_result(ptr: *const u8, len: usize) -> i32 {
    // If there's already a result, free it
    if !RESULT_PTR.is_null() {
        deallocate_result();
    }

    // Allocate new memory and copy the data
    let layout = std::alloc::Layout::from_size_align(len, 8).unwrap();
    RESULT_PTR = std::alloc::alloc(layout);
    RESULT_LEN = len;
    RESULT_CAP = len;

    // Check allocation success
    if RESULT_PTR.is_null() {
        return -1;
    }

    // Copy the data
    std::ptr::copy_nonoverlapping(ptr, RESULT_PTR, len);
    0
}

/// Gets the pointer to the stored result.
#[no_mangle]
pub unsafe extern "C" fn get_result_ptr() -> *const u8 {
    RESULT_PTR
}

/// Gets the length of the stored result.
#[no_mangle]
pub unsafe extern "C" fn get_result_len() -> usize {
    RESULT_LEN
}

/// Deallocates the stored result.
#[no_mangle]
pub unsafe extern "C" fn deallocate_result() {
    if !RESULT_PTR.is_null() {
        let layout = std::alloc::Layout::from_size_align(RESULT_CAP, 8).unwrap();
        std::alloc::dealloc(RESULT_PTR, layout);
        RESULT_PTR = std::ptr::null_mut();
        RESULT_LEN = 0;
        RESULT_CAP = 0;
    }
}

/// Parse an arithmetic expression and store the result.
/// Returns 0 on success, non-zero on error.
#[no_mangle]
pub unsafe extern "C" fn parse_expression(ptr: *const u8, len: usize) -> i32 {
    let input_bytes = std::slice::from_raw_parts(ptr, len);
    
    // Convert bytes to string
    match std::str::from_utf8(input_bytes) {
        Ok(input_str) => {
            // Parse the expression
            match parse(input_str) {
                Ok(result) => {
                    // Store the result
                    let result_bytes = result.as_bytes();
                    set_result(result_bytes.as_ptr(), result_bytes.len())
                }
                Err(e) => {
                    // Store the error message
                    let error_msg = format!("Error: {}", e);
                    let error_bytes = error_msg.as_bytes();
                    set_result(error_bytes.as_ptr(), error_bytes.len());
                    1
                }
            }
        }
        Err(_) => {
            // Invalid UTF-8
            let error_msg = "Error: invalid UTF-8 in input";
            let error_bytes = error_msg.as_bytes();
            set_result(error_bytes.as_ptr(), error_bytes.len());
            2
        }
    }
}

/// Get the current timestamp in milliseconds since the UNIX epoch.
/// This demonstrates using WASI to get system time.
#[no_mangle]
pub extern "C" fn get_timestamp_ms() -> u64 {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(duration) => duration.as_millis() as u64,
        Err(_) => 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_expression() {
        let input = "1+2";
        let input_bytes = input.as_bytes();
        
        unsafe {
            assert_eq!(parse_expression(input_bytes.as_ptr(), input_bytes.len()), 0);
            
            let result_ptr = get_result_ptr();
            let result_len = get_result_len();
            let result_bytes = std::slice::from_raw_parts(result_ptr, result_len);
            let result = std::str::from_utf8(result_bytes).unwrap();
            
            assert_eq!(result, "3");
            
            deallocate_result();
        }
    }
}
